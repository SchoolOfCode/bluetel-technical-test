# bluetel-technical-test

This is my completed technical test for Bluetel. I've created an API in Node.js that can add information about meter readings to a collection, with validation to ensure that all required information is provided and that customer ids cannot be duplicated.

## Usage

* First, to create a new entry to the meterreads collection, information for a customer needs to be added to the customers collection.
* Send a body of JSON to the customer/accept route, with the properties "customerId" and "name".
* e.g. 
```
{ "customerId": "identifier123", "name": "Indy Jones" }
```
* If this customer id does not already exist in the customers collection, a new customer will be created. This customer can be searched for at the customer/present route by handing the customerId into the query parameters.
* e.g. navigating to 
```
localhost:3000/customer/present?customerId=identifier123
```
will return
```
{
    "payload": {
        "customerId": "identifier123",
        "name": "Indy Jones",
        "_id": "5a8afaadc6872e13c42a3ba2",
        "__v": 0
    }
}
```
* Now that we have a customer, we can add some meter read data to our meterreads collection.
* We can hand in the data in our schema to the meter-read/accept route to have it added to the database.
* e.g.
```
{
    "customerId": "identifier123",
    "serialNumber": "27263927192",
    "mpxn": "14582749",
    "read": [
        {"type": "ANYTIME", "registerId": "387373", "value": "2729"},
        {"type": "NIGHT", "registerId": "387373", "value": "2892"}
    ],
    "readDate": "2017-11-20T16:19:48+00:00Z"
}
```
will return us...
```
{
    "payload": {
        "customer": "5a8afaadc6872e13c42a3ba2",
        "serialNumber": "27263927192",
        "mpxn": "2346789",
        "read": [
            {
                "readType": "ANYTIME",
                "registerId": "387373",
                "value": "2729",
                "_id": "5a8aea83b800da0c3cb402c9"
            },
            {
                "readType": "NIGHT",
                "registerId": "387373",
                "value": "2892",
                "_id": "5a8aea83b800da0c3cb402c8"
            }
        ],
        "readDate": "2017-11-20T16:19:48.000Z",
        "_id": "5a8aea83b800da0c3cb402ca",
        "__v": 0
    }
}
```
* In this way, we are not saving all of the customer's details in the meter read entry; we are only saving the unique id generated by MongoDB which we can use to refer to our customers collection.
* We can now search our meterreads collection by serialNumber or customerId. Doing so will return an array of data that fits our search criteria.
* e.g. if we navigate to
```
localhost:3000/meter-reads/present?customerId=identifier123&serialNumber=27263927192
```
we will return
```
{
    "payload": [
        {
            "read": [
                {
                    "readType": "ANYTIME",
                    "registerId": "387373",
                    "value": "2729",
                    "_id": "5a8afbf9c6872e13c42a3ba4"
                },
                {
                    "readType": "NIGHT",
                    "registerId": "387373",
                    "value": "2892",
                    "_id": "5a8afbf9c6872e13c42a3ba3"
                }
            ],
            "_id": "5a8afbf9c6872e13c42a3ba5",
            "customer": {
                "_id": "5a8afaadc6872e13c42a3ba2",
                "customerId": "identifier123",
                "name": "Indy Jones",
                "__v": 0
            },
            "serialNumber": "27263927192",
            "mpxn": "2346789",
            "readDate": "2017-11-20T16:19:48.000Z",
            "__v": 0
        }
    ]
}
```

## Notes

I have changed a few things in the schema. Most notably, I created a seperate collection for customers. This was to ensure that they would be unique while allowing me to add multiple meterreads for the same customer.
I changed "type" to "readType" as the word "type" is reserved in Mongoose, the node package I was using to manage my database.
I also slightly reformatted the "readDate" to be a date format that could be easily read by JavaScript.

My tests are not accessing the live database. The test database has been populated with dummy data that fulfills the criteria of a live environment. This allows me to add content to a database and receive expected responses with out filling up the live database.

Thank you for taking the time to review my test. If there are any further questions that I can answer, I would love to hear them.

Regards,
Ben Rosell
